---
layout:     post
title:      Walle路由库优化设计方案
subtitle:   组件化解耦思想
date:       2019-08-06
author:     Tristan
header-img: img/walle_bg.png
catalog: true
tags:
    - 解耦
    - api聚合
    - 异步处理
    
---

### 背景
路由库Walle的存在很好的解除了业务层和底层库的直接耦合，但是随着各个底层库的接入，这时发现一些问题。比如：接入定位库后，实现异步回调功能变得复杂；之后在设计上，因为封装返回数据Bean和异步逻辑处理，导致多产生一个库WalleExtLib。而我们对这个库的定义自始是不明确的，最后影响了项目中的整个依赖关系结构。

### 路由职能
* **解耦**
  在两个库不依赖的前提下实现两者之间的页面和功能调用，各个业务库调用底层库逻辑时非直接依赖关系。典型的例子：58ClientHybridLib中存在很多触发登陆模块的代码，但是看依赖关系，这个库是没有依赖WubaLoginLib的。这就是Walle路由的作用。
```
WubaClientHybridLib = [
      switchs['58ClientHybridLib'] ? "com.wuba.wuxian.lib:58ClientHybridLib:" + "$WubaClientHybridLibVersion" : findProject(':58ClientHybridLib'),
      rootProject.ext.WubaAppDependenciesLib,
      rootProject.ext.WubaWebBusinessLib,
      rootProject.ext.WubaBasicBusinessLib,
      rootProject.ext.WubaRNLib,
      rootProject.ext.WubaRNExt,
      rootProject.ext.LoginSDK,
      rootProject.ext.WubaIMLib,
      rootProject.ext.WubaLocationLib,
      rootProject.ext.WubaVideoLib,
      rootProject.ext.WPush,
      rootProject.ext.WubaMultiDexLib,
      rootProject.ext.WubaShareLib,
      rootProject.ext.AndroidPlatformService,
      "com.wuba.wmda:wmda:$WmdaVersion",
      'com.facebook.fbui.textlayoutbuilder:textlayoutbuilder:1.0.0',
      'com.squareup.okhttp3:okhttp-urlconnection:3.11.0',
      'javax.inject:javax.inject:1',
      rootProject.ext.RecyclerView,
      rootProject.ext.DeviceID,
      'com.getui:gisdk:3.1.6.0',
      'com.alibaba:arouter-api:1.4.0',
      'com.wuba.wuxian.sdk:ttsdk:2.8.0.3-58',
      'com.bun.miitmdid:miitmdid:1.0.10', //MSA SDK 补充设备标识符
      rootProject.ext.WubaNetMonitorSDK,
]
```
* 页面跳转
   对接了现有的**跳转中心**模块，此模块支持按**跳转协议**直接跳转到落地页。
```
WubaWalleLib = [
      switchs['WubaWalleLib'] ? "com.wuba.wuxian.lib:WubaWalleLib:" + "$WubaWalleLibVersion" : findProject(':WubaWalleLib'),
      rootProject.ext.JumpCenterSDK,
      rootProject.ext.WubaLogLib
]
```
* 模块调用
  业务线和中间件实现平行开发，互不依赖。hybrid和login是完全两条并行的业务，它们在业务上是强依赖的，但是在代码层没有产生依赖。
  > 业务线和底层库也应该是平行概念，但是目前的实现上没有完全解耦合，hybrid强依赖location；hybrid虽然没有依赖login，然而直接依赖了passport，这是不合理的。

![walle-依赖结构(优化前1).jpg](https://upload-images.jianshu.io/upload_images/5316611-2bac07ac46c1e76b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### Walle缺陷
* 异步调用实现逻辑复杂
![walle-定位(优化前).jpg](https://upload-images.jianshu.io/upload_images/5316611-d6f9a1408537bf3a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 依赖问题
  1. WalleExtLib多余设计

* 方法的入口参数设置过于灵活，导致API设计聚合力差

```
Request request = Request.obtain()
                  .setPath("im/startChatDetail")
                  .addQuery("protocol", content);
Walle.route(context, request);

Request request = Request.obtain()
                  .setPath("location/getLocationCityIsAbroad");
Response data = Walle.route(request);
```

* 避讳的设计
  1. 通知
  2. 注册和反注册实现

### 本次优化
  1. 统一Walle的调用方法，保留一个创建接口的方法
   * 上层业务按模块统一定义在接口类中，实现聚类，而非松散。
```
ILocationService iLocationService = Walle.create(ILocationService.class);
Response response = iLocationService.getLocationCityIsAbroad();
```
  2. 通过接口定义底层库方法入口，暴露给业务的是接口而不是类的实例和方法
```
public interface ILocationService {
    @Action(uri = "location/getLocationCityIsAbroad")
    Response getLocationCityIsAbroad();
}
```
  3. 优化异步调用实现，通过RxJava实现简单的异步调用，废除业务中间层复杂的注册和反注册实现
```
public interface ILocationService {
    @Action(uri = "location/observeLocation")
    Observable<Response> observeLocation();
}
```
> 引入RxJava直接给业务层返回Observable对象，从而取消了注册和反注册以及通知机制，简化了整个异步调用逻辑。
  4. 废除WalleExtLib库，还原依赖关系，依赖结构更清晰
![walle-定位(优化后 ).jpg](https://upload-images.jianshu.io/upload_images/5316611-d81f04bf3afd1339.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 方案设计
  1. 动态代理
  * **通过实现InvocationHandler接口创建自己的调用处理器 IvocationHandler handler = new InvocationHandlerImpl(...);**
  * 通过为Proxy类指定ClassLoader对象和一组interface代理类需要实现的接口，创建动态代理类类文件，默认JDK并不会保存这个文件到文件中；可以保存起来观察生成的代理类结构Class clazz = Proxy.getProxyClass(classLoader,new Class[]{...});
  * 通过上面新建的代理clazz的反射机制获取动态代理类的一个构造函数，其构造函数入参类型是调用处理器接口(IvocationHandler)类型 Constructor constructor = clazz.getConstructor(new Class[]{InvocationHandler.class});
  * 通过构造函数实例创建代理类实例，此时需将调用处理器对象作为参数被传入 Interface Proxy = (Interface)constructor.newInstance(new Object[] (handler)); 为了简化对象创建过程，Proxy类中的newInstance工具方法封装了2~4，只需两步即可完成代理对象的创建。
```
public static <T> T create(Class<T> service, final Context context) {
    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[]{service}, new InvocationHandler() {
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            Action action = method.getAnnotation(Action.class);
            Request request = Request.obtain().setPath(action.uri());
            Annotation[][] annotations = method.getParameterAnnotations();
            if (annotations != null && args != null && args.length > 0) {
                ...
                request.addQuery(map);
            }
            return Walle.route(context, request, ...);
        }
    });
}
```
  2. 注解，实现参数配置

```
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Action {
    String uri();
    String authority() default AUTH_COM;
}
```
```
@Target(ElementType.PARAMETER)
@Retention(RetentionPolicy.RUNTIME)
public @interface Query {
    String value();
}
```
```
public interface ILocationService {

    @Action(uri = "location/getLocationCityIsAbroad")
    Response getLocationCityIsAbroad();

    @Action(uri = "location/requestLocation")
    Response requestLocation(@Query("location.force_locate") boolean isForceLocate);

    @Action(uri = "location/resumeLocation")
    Response resumeLocation();

    @Action(uri = "location/stopLocation")
    Response stopLocation();

    @Action(uri = "location/observeLocation")
    Observable<Response> observeLocation();

}
```
  3. 反射

  4. Rxjava，替代注册和反注册实现
```
method.getReturnType() == Observable.class ? Action.Method.ASYNC : Action.Method.SYNC
```

整体架构图如下：
![walle-新版本.jpg](https://upload-images.jianshu.io/upload_images/5316611-8c41ce2e8ef56553.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 优化后的效果
1. 调用方式
~~~
public interface ILocationService {
    @Action(uri = "location/getLocationCityIsAbroad")
    Response getLocationCityIsAbroad();

    @Action(uri = "location/observeLocation")
    Observable<Response> observeLocation();
}
~~~
~~~
public static boolean getLocationCityIsAbroad() {
    ILocationService iLocationService = Walle.create(ILocationService.class);
    Response response = iLocationService.getLocationCityIsAbroad();
    return response.getBoolean("result");
}
~~~
~~~
public static Observable<ILocation.WubaLocationData> getPosition(boolean isUpdate) {
    ILocationService iLocationService = Walle.create(ILocationService.class);
    return iLocationService.observeLocation().map(new Func1<Response, ILocation.WubaLocationData>() {
        @Override
        public ILocation.WubaLocationData call(Response response) {
            return (ILocation.WubaLocationData) response.getParcelable("location.result");
        }
    });
}
~~~
  
2. 依赖关系图对比
![walle-依赖结构(优化前).jpg](https://upload-images.jianshu.io/upload_images/5316611-6ca65d223d6505df.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![walle-依赖关系(优化后).jpg](https://upload-images.jianshu.io/upload_images/5316611-a92b818b2ae766a6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

